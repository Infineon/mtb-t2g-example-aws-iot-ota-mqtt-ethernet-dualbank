/**********************************************************************************************************************
 * \file mqtt_subscription_manager.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
/* Standard includes. */
#include <string.h>
#include <assert.h>

/* Include header for the subscription manager. */
#include "mqtt_subscription_manager.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @brief Represents a registered record of the topic filter and its associated callback
 * in the subscription manager registry.
 */
typedef struct SubscriptionManagerRecord
{
    const char * pTopicFilter;
    uint16_t topicFilterLength;
    SubscriptionManagerCallback_t callback;
} SubscriptionManagerRecord_t;

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @brief The default value for the maximum size of the callback registry in the
 * subscription manager.
 */
#ifndef MAX_SUBSCRIPTION_CALLBACK_RECORDS
#define MAX_SUBSCRIPTION_CALLBACK_RECORDS    5
#endif

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @brief The registry to store records of topic filters and their subscription callbacks.
 */
static SubscriptionManagerRecord_t g_callbackRecordList[ MAX_SUBSCRIPTION_CALLBACK_RECORDS ] = { 0 };


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: SubscriptionManager_DispatchHandler
 * Summary:
 *  Dispatches the incoming PUBLISH message to the callbacks that have their registered topic filters matching the incoming
 *  PUBLISH topic name. The dispatch handler will invoke all these callbacks with matching topic filters.
 * Parameters:
 *  handle:  The handle associated with the MQTT connection.
 *  pPublishInfo: The incoming PUBLISH message information.
 * Return:
 *  void
 **********************************************************************************************************************
 */
void SubscriptionManager_DispatchHandler(cy_mqtt_t handle, cy_mqtt_received_msg_info_t *pPublishInfo)
{
    bool matchStatus = false;
    size_t listIndex = 0u;

    assert(pPublishInfo != NULL);
    assert(handle != NULL);

    /* Iterate through record list to find matching topics, and invoke their callbacks. */
    for (listIndex = 0; listIndex < MAX_SUBSCRIPTION_CALLBACK_RECORDS; listIndex++)
    {
        if ((g_callbackRecordList[ listIndex ].pTopicFilter != NULL) &&
                (MQTT_MatchTopic(pPublishInfo->topic,
                        pPublishInfo->topic_len,
                        g_callbackRecordList[ listIndex ].pTopicFilter,
                        g_callbackRecordList[ listIndex ].topicFilterLength,
                        &matchStatus) == MQTTSuccess) &&
                        (matchStatus == true))
        {
            LogInfo(("Invoking subscription callback of matching topic filter: "
                    "TopicFilter=%.*s, TopicName=%.*s",
                    g_callbackRecordList[ listIndex ].topicFilterLength,
                    g_callbackRecordList[ listIndex ].pTopicFilter,
                    pPublishInfo->topic,
                    pPublishInfo->topic_len));

            /* Invoke the callback associated with the record as the topics match. */
            g_callbackRecordList[ listIndex ].callback(handle, pPublishInfo);
        }
    }
}

/**********************************************************************************************************************
 * Function Name: SubscriptionManager_RegisterCallback
 * Summary:
 *  Utility to register a callback for a topic filter in the subscription manager.
 *  The callback will be invoked when an incoming PUBLISH message is received on a topic that matches the topic filter,
 *  pTopicFilter. The subscription manager accepts wildcard topic filters.
 * Parameters:
 *  pTopicFilter: filter string
 *  topicFilterLength: filter string length
 *  callback: callback function pointer
 * Return:
 *  SubscriptionManagerStatus_t
 **********************************************************************************************************************
 */
SubscriptionManagerStatus_t SubscriptionManager_RegisterCallback(const char * pTopicFilter,
        uint16_t topicFilterLength,
        SubscriptionManagerCallback_t callback)
{
    assert(pTopicFilter != NULL);
    assert(topicFilterLength != 0);
    assert(callback != NULL);

    SubscriptionManagerStatus_t returnStatus;
    size_t availableIndex = MAX_SUBSCRIPTION_CALLBACK_RECORDS;
    bool recordExists = false;
    size_t index = 0u;

    /* Search for the first available spot in the list to store the record, and also check if
     * a record for the topic filter already exists. */
    while ((recordExists == false) && (index < MAX_SUBSCRIPTION_CALLBACK_RECORDS))
    {
        /* Check if the index represents an empty spot in the registry. If we had already
         * found an empty spot in the list, we will not update it. */
        if ((availableIndex == MAX_SUBSCRIPTION_CALLBACK_RECORDS) &&
                (g_callbackRecordList[ index ].pTopicFilter == NULL))
        {
            availableIndex = index;
        }

        /* Check if the current record's topic filter in the registry matches the topic filter
         * we are trying to register. */
        else if ((g_callbackRecordList[ index ].topicFilterLength == topicFilterLength) &&
                (strncmp(pTopicFilter, g_callbackRecordList[ index ].pTopicFilter,
                        topicFilterLength) == 0))
        {
            recordExists = true;
        }

        index++;
    }

    if (recordExists == true)
    {
        /* The record for the topic filter already exists. */
        LogError(("Failed to register callback: Record for topic filter "
                "already exists: TopicFilter=%.*s", topicFilterLength, pTopicFilter));

        returnStatus = SUBSCRIPTION_MANAGER_RECORD_EXISTS;
    }
    else if (availableIndex == MAX_SUBSCRIPTION_CALLBACK_RECORDS)
    {
        /* The registry is full. */
        LogError(("Unable to register callback: Registry list is full: "
                "TopicFilter=%.*s, MaxRegistrySize=%u", topicFilterLength,
                pTopicFilter, MAX_SUBSCRIPTION_CALLBACK_RECORDS));

        returnStatus = SUBSCRIPTION_MANAGER_REGISTRY_FULL;
    }
    else
    {
        g_callbackRecordList[ availableIndex ].pTopicFilter = pTopicFilter;
        g_callbackRecordList[ availableIndex ].topicFilterLength = topicFilterLength;
        g_callbackRecordList[ availableIndex ].callback = callback;

        returnStatus = SUBSCRIPTION_MANAGER_SUCCESS;

        LogDebug(("Added callback to registry: TopicFilter=%.*s",
                topicFilterLength,
                pTopicFilter));
    }

    return returnStatus;
}

/**********************************************************************************************************************
 * Function Name: SubscriptionManager_RemoveCallback
 * Summary:
 *  Utility to remove the callback registered for a topic filter from the subscription manager.
 * Parameters:
 *  pTopicFilter: The topic filter to remove from the subscription manager.
 *  topicFilterLength: The length of the topic filter string.
 * Return:
 *  void
 **********************************************************************************************************************
 */
void SubscriptionManager_RemoveCallback(const char * pTopicFilter, uint16_t topicFilterLength)
{
    assert(pTopicFilter != NULL);
    assert(topicFilterLength != 0);

    size_t index;
    SubscriptionManagerRecord_t * pRecord = NULL;

    /* Iterate through the records list to find the matching record. */
    for (index = 0; index < MAX_SUBSCRIPTION_CALLBACK_RECORDS; index++)
    {
        pRecord = &g_callbackRecordList[ index ];

        /* Only match the non-empty records. */
        if (pRecord->pTopicFilter != NULL)
        {
            if ((topicFilterLength == pRecord->topicFilterLength) &&
                    (strncmp(pTopicFilter, pRecord->pTopicFilter, topicFilterLength) == 0))
            {
                break;
            }
        }
    }

    /* Delete the record by clearing the found entry in the records list. */
    if (index < MAX_SUBSCRIPTION_CALLBACK_RECORDS)
    {
        pRecord->pTopicFilter = NULL;
        pRecord->topicFilterLength = 0u;
        pRecord->callback = NULL;

        LogDebug(("Deleted callback record for topic filter: TopicFilter=%.*s",
                topicFilterLength,
                pTopicFilter));
    }
    else
    {
        LogWarn(("Attempted to remove callback for un-registered "
                "topic filter: TopicFilter=%.*s", topicFilterLength, pTopicFilter));
    }
}

/* [] END OF FILE */
